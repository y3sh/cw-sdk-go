// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: markets/market.proto

package ProtobufMarkets

/*
	NOTE: While a lot of these types have been expanded to indices, to prevent
	breaking clients by changing protbuf message types and names
	we'll just leave the package as ProtobufMarkets
*/

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Market represents a currency pair on a particular exchange.
type Market struct {
	// Prefer integer ids to string slugs (far fewer bytes)
	ExchangeId     uint64 `protobuf:"varint,3,opt,name=exchangeId,proto3" json:"exchangeId,omitempty"`
	CurrencyPairId uint64 `protobuf:"varint,4,opt,name=currencyPairId,proto3" json:"currencyPairId,omitempty"`
	// New IDs from SQL; TODO remove 1,2,3,4 when migrationt o 5,6 is complete
	MarketId uint64 `protobuf:"varint,5,opt,name=marketId,proto3" json:"marketId,omitempty"`
	// Deprecated
	Exchange             string   `protobuf:"bytes,1,opt,name=exchange,proto3" json:"exchange,omitempty"`
	CurrencyPair         string   `protobuf:"bytes,2,opt,name=currencyPair,proto3" json:"currencyPair,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{0}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(dst, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetExchangeId() uint64 {
	if m != nil {
		return m.ExchangeId
	}
	return 0
}

func (m *Market) GetCurrencyPairId() uint64 {
	if m != nil {
		return m.CurrencyPairId
	}
	return 0
}

func (m *Market) GetMarketId() uint64 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *Market) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *Market) GetCurrencyPair() string {
	if m != nil {
		return m.CurrencyPair
	}
	return ""
}

// Order represents an ask or a bid.
type Order struct {
	PriceStr  string `protobuf:"bytes,3,opt,name=priceStr,proto3" json:"priceStr,omitempty"`
	AmountStr string `protobuf:"bytes,4,opt,name=amountStr,proto3" json:"amountStr,omitempty"`
	// Deprecated
	Price                float32  `protobuf:"fixed32,1,opt,name=price,proto3" json:"price,omitempty"`
	Amount               float32  `protobuf:"fixed32,2,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{1}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(dst, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *Order) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

func (m *Order) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// Trade is a single trade in TradesUpdate
type Trade struct {
	// Exchange-specific ID
	ExternalId      string `protobuf:"bytes,11,opt,name=externalId,proto3" json:"externalId,omitempty"`
	Timestamp       int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TimestampMillis int64  `protobuf:"varint,5,opt,name=timestampMillis,proto3" json:"timestampMillis,omitempty"`
	TimestampNano   int64  `protobuf:"varint,10,opt,name=timestampNano,proto3" json:"timestampNano,omitempty"`
	PriceStr        string `protobuf:"bytes,8,opt,name=priceStr,proto3" json:"priceStr,omitempty"`
	AmountStr       string `protobuf:"bytes,9,opt,name=amountStr,proto3" json:"amountStr,omitempty"`
	// Deprecated
	Price                float32  `protobuf:"fixed32,3,opt,name=price,proto3" json:"price,omitempty"`
	Amount               float32  `protobuf:"fixed32,4,opt,name=amount,proto3" json:"amount,omitempty"`
	PriceDouble          float64  `protobuf:"fixed64,6,opt,name=priceDouble,proto3" json:"priceDouble,omitempty"`
	AmountDouble         float64  `protobuf:"fixed64,7,opt,name=amountDouble,proto3" json:"amountDouble,omitempty"`
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{2}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(dst, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *Trade) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Trade) GetTimestampMillis() int64 {
	if m != nil {
		return m.TimestampMillis
	}
	return 0
}

func (m *Trade) GetTimestampNano() int64 {
	if m != nil {
		return m.TimestampNano
	}
	return 0
}

func (m *Trade) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *Trade) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

func (m *Trade) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Trade) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Trade) GetPriceDouble() float64 {
	if m != nil {
		return m.PriceDouble
	}
	return 0
}

func (m *Trade) GetAmountDouble() float64 {
	if m != nil {
		return m.AmountDouble
	}
	return 0
}

func (m *Trade) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// MarketUpdateMessage is the primary message for market updates; it wraps all
// other more specific update types.
type MarketUpdateMessage struct {
	Market *Market `protobuf:"bytes,9,opt,name=market,proto3" json:"market,omitempty"`
	// Types that are valid to be assigned to Update:
	//	*MarketUpdateMessage_OrderBookUpdate
	//	*MarketUpdateMessage_OrderBookDeltaUpdate
	//	*MarketUpdateMessage_OrderBookSpreadUpdate
	//	*MarketUpdateMessage_TradesUpdate
	//	*MarketUpdateMessage_IntervalsUpdate
	//	*MarketUpdateMessage_SummaryUpdate
	//	*MarketUpdateMessage_SparklineUpdate
	Update               isMarketUpdateMessage_Update `protobuf_oneof:"Update"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *MarketUpdateMessage) Reset()         { *m = MarketUpdateMessage{} }
func (m *MarketUpdateMessage) String() string { return proto.CompactTextString(m) }
func (*MarketUpdateMessage) ProtoMessage()    {}
func (*MarketUpdateMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{3}
}
func (m *MarketUpdateMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketUpdateMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketUpdateMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarketUpdateMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketUpdateMessage.Merge(dst, src)
}
func (m *MarketUpdateMessage) XXX_Size() int {
	return m.Size()
}
func (m *MarketUpdateMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketUpdateMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MarketUpdateMessage proto.InternalMessageInfo

type isMarketUpdateMessage_Update interface {
	isMarketUpdateMessage_Update()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MarketUpdateMessage_OrderBookUpdate struct {
	OrderBookUpdate *OrderBookUpdate `protobuf:"bytes,2,opt,name=orderBookUpdate,proto3,oneof"`
}
type MarketUpdateMessage_OrderBookDeltaUpdate struct {
	OrderBookDeltaUpdate *OrderBookDeltaUpdate `protobuf:"bytes,3,opt,name=orderBookDeltaUpdate,proto3,oneof"`
}
type MarketUpdateMessage_OrderBookSpreadUpdate struct {
	OrderBookSpreadUpdate *OrderBookSpreadUpdate `protobuf:"bytes,11,opt,name=orderBookSpreadUpdate,proto3,oneof"`
}
type MarketUpdateMessage_TradesUpdate struct {
	TradesUpdate *TradesUpdate `protobuf:"bytes,4,opt,name=tradesUpdate,proto3,oneof"`
}
type MarketUpdateMessage_IntervalsUpdate struct {
	IntervalsUpdate *IntervalsUpdate `protobuf:"bytes,5,opt,name=intervalsUpdate,proto3,oneof"`
}
type MarketUpdateMessage_SummaryUpdate struct {
	SummaryUpdate *SummaryUpdate `protobuf:"bytes,6,opt,name=summaryUpdate,proto3,oneof"`
}
type MarketUpdateMessage_SparklineUpdate struct {
	SparklineUpdate *SparklineUpdate `protobuf:"bytes,7,opt,name=sparklineUpdate,proto3,oneof"`
}

func (*MarketUpdateMessage_OrderBookUpdate) isMarketUpdateMessage_Update()       {}
func (*MarketUpdateMessage_OrderBookDeltaUpdate) isMarketUpdateMessage_Update()  {}
func (*MarketUpdateMessage_OrderBookSpreadUpdate) isMarketUpdateMessage_Update() {}
func (*MarketUpdateMessage_TradesUpdate) isMarketUpdateMessage_Update()          {}
func (*MarketUpdateMessage_IntervalsUpdate) isMarketUpdateMessage_Update()       {}
func (*MarketUpdateMessage_SummaryUpdate) isMarketUpdateMessage_Update()         {}
func (*MarketUpdateMessage_SparklineUpdate) isMarketUpdateMessage_Update()       {}

func (m *MarketUpdateMessage) GetUpdate() isMarketUpdateMessage_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *MarketUpdateMessage) GetMarket() *Market {
	if m != nil {
		return m.Market
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookUpdate() *OrderBookUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookUpdate); ok {
		return x.OrderBookUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookDeltaUpdate() *OrderBookDeltaUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookDeltaUpdate); ok {
		return x.OrderBookDeltaUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookSpreadUpdate() *OrderBookSpreadUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookSpreadUpdate); ok {
		return x.OrderBookSpreadUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetTradesUpdate() *TradesUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_TradesUpdate); ok {
		return x.TradesUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetIntervalsUpdate() *IntervalsUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_IntervalsUpdate); ok {
		return x.IntervalsUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSummaryUpdate() *SummaryUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SummaryUpdate); ok {
		return x.SummaryUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSparklineUpdate() *SparklineUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SparklineUpdate); ok {
		return x.SparklineUpdate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MarketUpdateMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MarketUpdateMessage_OneofMarshaler, _MarketUpdateMessage_OneofUnmarshaler, _MarketUpdateMessage_OneofSizer, []interface{}{
		(*MarketUpdateMessage_OrderBookUpdate)(nil),
		(*MarketUpdateMessage_OrderBookDeltaUpdate)(nil),
		(*MarketUpdateMessage_OrderBookSpreadUpdate)(nil),
		(*MarketUpdateMessage_TradesUpdate)(nil),
		(*MarketUpdateMessage_IntervalsUpdate)(nil),
		(*MarketUpdateMessage_SummaryUpdate)(nil),
		(*MarketUpdateMessage_SparklineUpdate)(nil),
	}
}

func _MarketUpdateMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MarketUpdateMessage)
	// Update
	switch x := m.Update.(type) {
	case *MarketUpdateMessage_OrderBookUpdate:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_OrderBookDeltaUpdate:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookDeltaUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_OrderBookSpreadUpdate:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookSpreadUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_TradesUpdate:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TradesUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_IntervalsUpdate:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntervalsUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SummaryUpdate:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SummaryUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SparklineUpdate:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparklineUpdate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MarketUpdateMessage.Update has unexpected type %T", x)
	}
	return nil
}

func _MarketUpdateMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MarketUpdateMessage)
	switch tag {
	case 2: // Update.orderBookUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookUpdate{msg}
		return true, err
	case 3: // Update.orderBookDeltaUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookDeltaUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookDeltaUpdate{msg}
		return true, err
	case 11: // Update.orderBookSpreadUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookSpreadUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookSpreadUpdate{msg}
		return true, err
	case 4: // Update.tradesUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TradesUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_TradesUpdate{msg}
		return true, err
	case 5: // Update.intervalsUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntervalsUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_IntervalsUpdate{msg}
		return true, err
	case 6: // Update.summaryUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SummaryUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SummaryUpdate{msg}
		return true, err
	case 7: // Update.sparklineUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparklineUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SparklineUpdate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MarketUpdateMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MarketUpdateMessage)
	// Update
	switch x := m.Update.(type) {
	case *MarketUpdateMessage_OrderBookUpdate:
		s := proto.Size(x.OrderBookUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_OrderBookDeltaUpdate:
		s := proto.Size(x.OrderBookDeltaUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_OrderBookSpreadUpdate:
		s := proto.Size(x.OrderBookSpreadUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_TradesUpdate:
		s := proto.Size(x.TradesUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_IntervalsUpdate:
		s := proto.Size(x.IntervalsUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SummaryUpdate:
		s := proto.Size(x.SummaryUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SparklineUpdate:
		s := proto.Size(x.SparklineUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// OrderBookUpdate represents a snapshot of the order book: a set of asks and
// bids for the particular aggregation modulus.
type OrderBookUpdate struct {
	// Aggregation modulus is a value which all bids and asks in this particular
	// OrderBookUpdate are divisible by. E.g. could be 1 (no aggregation), 5, 10,
	// 50, 100, etc. Exact possible values are set for each market individually.
	AggregationModulusStr string   `protobuf:"bytes,4,opt,name=aggregationModulusStr,proto3" json:"aggregationModulusStr,omitempty"`
	SeqNum                int32    `protobuf:"varint,5,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
	Bids                  []*Order `protobuf:"bytes,1,rep,name=bids,proto3" json:"bids,omitempty"`
	Asks                  []*Order `protobuf:"bytes,2,rep,name=asks,proto3" json:"asks,omitempty"`
	// Deprecated
	AggregationModulus   float32  `protobuf:"fixed32,3,opt,name=aggregationModulus,proto3" json:"aggregationModulus,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderBookUpdate) Reset()         { *m = OrderBookUpdate{} }
func (m *OrderBookUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookUpdate) ProtoMessage()    {}
func (*OrderBookUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{4}
}
func (m *OrderBookUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookUpdate.Merge(dst, src)
}
func (m *OrderBookUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookUpdate proto.InternalMessageInfo

func (m *OrderBookUpdate) GetAggregationModulusStr() string {
	if m != nil {
		return m.AggregationModulusStr
	}
	return ""
}

func (m *OrderBookUpdate) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *OrderBookUpdate) GetBids() []*Order {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookUpdate) GetAsks() []*Order {
	if m != nil {
		return m.Asks
	}
	return nil
}

func (m *OrderBookUpdate) GetAggregationModulus() float32 {
	if m != nil {
		return m.AggregationModulus
	}
	return 0
}

// OrderBookDeltaUpdate represents a delta which needs to be applied to the
// local order book.
type OrderBookDeltaUpdate struct {
	// Aggregation modulus is a value which all bids and asks in this particular
	// OrderBookUpdate are divisible by. E.g. could be 1 (no aggregation), 5, 10,
	// 50, 100, etc. Exact possible values are set for each market individually.
	AggregationModulus    float32 `protobuf:"fixed32,3,opt,name=aggregationModulus,proto3" json:"aggregationModulus,omitempty"`
	AggregationModulusStr string  `protobuf:"bytes,4,opt,name=aggregationModulusStr,proto3" json:"aggregationModulusStr,omitempty"`
	SeqNum                int32   `protobuf:"varint,5,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
	// Deltas for bids
	Bids *OrderBookDeltaUpdate_OrderDeltas `protobuf:"bytes,1,opt,name=bids,proto3" json:"bids,omitempty"`
	// Deltas for asks
	Asks                 *OrderBookDeltaUpdate_OrderDeltas `protobuf:"bytes,2,opt,name=asks,proto3" json:"asks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *OrderBookDeltaUpdate) Reset()         { *m = OrderBookDeltaUpdate{} }
func (m *OrderBookDeltaUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookDeltaUpdate) ProtoMessage()    {}
func (*OrderBookDeltaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{5}
}
func (m *OrderBookDeltaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookDeltaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookDeltaUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookDeltaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookDeltaUpdate.Merge(dst, src)
}
func (m *OrderBookDeltaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookDeltaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookDeltaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookDeltaUpdate proto.InternalMessageInfo

func (m *OrderBookDeltaUpdate) GetAggregationModulus() float32 {
	if m != nil {
		return m.AggregationModulus
	}
	return 0
}

func (m *OrderBookDeltaUpdate) GetAggregationModulusStr() string {
	if m != nil {
		return m.AggregationModulusStr
	}
	return ""
}

func (m *OrderBookDeltaUpdate) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *OrderBookDeltaUpdate) GetBids() *OrderBookDeltaUpdate_OrderDeltas {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookDeltaUpdate) GetAsks() *OrderBookDeltaUpdate_OrderDeltas {
	if m != nil {
		return m.Asks
	}
	return nil
}

type OrderBookDeltaUpdate_OrderDeltas struct {
	// Either add a new order at a particular price, or replace existing one
	// (with the new amount)
	Set []*Order `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
	// TODO: I see we don't really use deltas, and just use set?
	Delta []*Order `protobuf:"bytes,2,rep,name=delta,proto3" json:"delta,omitempty"`
	// Remove order at a particular price
	Remove               []float32 `protobuf:"fixed32,3,rep,name=remove,proto3" json:"remove,omitempty"`
	RemoveStr            []string  `protobuf:"bytes,4,rep,name=removeStr,proto3" json:"removeStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Reset()         { *m = OrderBookDeltaUpdate_OrderDeltas{} }
func (m *OrderBookDeltaUpdate_OrderDeltas) String() string { return proto.CompactTextString(m) }
func (*OrderBookDeltaUpdate_OrderDeltas) ProtoMessage()    {}
func (*OrderBookDeltaUpdate_OrderDeltas) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{5, 0}
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookDeltaUpdate_OrderDeltas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas.Merge(dst, src)
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas proto.InternalMessageInfo

func (m *OrderBookDeltaUpdate_OrderDeltas) GetSet() []*Order {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetDelta() []*Order {
	if m != nil {
		return m.Delta
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetRemove() []float32 {
	if m != nil {
		return m.Remove
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetRemoveStr() []string {
	if m != nil {
		return m.RemoveStr
	}
	return nil
}

// OrderBookSpreadUpdate represents only the best bid & ask
type OrderBookSpreadUpdate struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Bid                  *Order   `protobuf:"bytes,2,opt,name=bid,proto3" json:"bid,omitempty"`
	Ask                  *Order   `protobuf:"bytes,3,opt,name=ask,proto3" json:"ask,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderBookSpreadUpdate) Reset()         { *m = OrderBookSpreadUpdate{} }
func (m *OrderBookSpreadUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookSpreadUpdate) ProtoMessage()    {}
func (*OrderBookSpreadUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{6}
}
func (m *OrderBookSpreadUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookSpreadUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookSpreadUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookSpreadUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookSpreadUpdate.Merge(dst, src)
}
func (m *OrderBookSpreadUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookSpreadUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookSpreadUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookSpreadUpdate proto.InternalMessageInfo

func (m *OrderBookSpreadUpdate) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *OrderBookSpreadUpdate) GetBid() *Order {
	if m != nil {
		return m.Bid
	}
	return nil
}

func (m *OrderBookSpreadUpdate) GetAsk() *Order {
	if m != nil {
		return m.Ask
	}
	return nil
}

// TradesUpdate represents a set of new trades.
type TradesUpdate struct {
	Trades               []*Trade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradesUpdate) Reset()         { *m = TradesUpdate{} }
func (m *TradesUpdate) String() string { return proto.CompactTextString(m) }
func (*TradesUpdate) ProtoMessage()    {}
func (*TradesUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{7}
}
func (m *TradesUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradesUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradesUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TradesUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradesUpdate.Merge(dst, src)
}
func (m *TradesUpdate) XXX_Size() int {
	return m.Size()
}
func (m *TradesUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_TradesUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_TradesUpdate proto.InternalMessageInfo

func (m *TradesUpdate) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

// Interval represents a single OHLC candle.
type Interval struct {
	Closetime      int64          `protobuf:"varint,1,opt,name=closetime,proto3" json:"closetime,omitempty"`
	Period         int32          `protobuf:"varint,4,opt,name=period,proto3" json:"period,omitempty"`
	Ohlc           *Interval_OHLC `protobuf:"bytes,2,opt,name=ohlc,proto3" json:"ohlc,omitempty"`
	VolumeBaseStr  string         `protobuf:"bytes,6,opt,name=volumeBaseStr,proto3" json:"volumeBaseStr,omitempty"`
	VolumeQuoteStr string         `protobuf:"bytes,7,opt,name=volumeQuoteStr,proto3" json:"volumeQuoteStr,omitempty"`
	// Deprecated
	VolumeBase           float32  `protobuf:"fixed32,3,opt,name=volumeBase,proto3" json:"volumeBase,omitempty"`
	VolumeQuote          float32  `protobuf:"fixed32,5,opt,name=volumeQuote,proto3" json:"volumeQuote,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Interval) Reset()         { *m = Interval{} }
func (m *Interval) String() string { return proto.CompactTextString(m) }
func (*Interval) ProtoMessage()    {}
func (*Interval) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{8}
}
func (m *Interval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Interval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interval.Merge(dst, src)
}
func (m *Interval) XXX_Size() int {
	return m.Size()
}
func (m *Interval) XXX_DiscardUnknown() {
	xxx_messageInfo_Interval.DiscardUnknown(m)
}

var xxx_messageInfo_Interval proto.InternalMessageInfo

func (m *Interval) GetClosetime() int64 {
	if m != nil {
		return m.Closetime
	}
	return 0
}

func (m *Interval) GetPeriod() int32 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *Interval) GetOhlc() *Interval_OHLC {
	if m != nil {
		return m.Ohlc
	}
	return nil
}

func (m *Interval) GetVolumeBaseStr() string {
	if m != nil {
		return m.VolumeBaseStr
	}
	return ""
}

func (m *Interval) GetVolumeQuoteStr() string {
	if m != nil {
		return m.VolumeQuoteStr
	}
	return ""
}

func (m *Interval) GetVolumeBase() float32 {
	if m != nil {
		return m.VolumeBase
	}
	return 0
}

func (m *Interval) GetVolumeQuote() float32 {
	if m != nil {
		return m.VolumeQuote
	}
	return 0
}

type Interval_OHLC struct {
	OpenStr  string `protobuf:"bytes,5,opt,name=openStr,proto3" json:"openStr,omitempty"`
	HighStr  string `protobuf:"bytes,6,opt,name=highStr,proto3" json:"highStr,omitempty"`
	LowStr   string `protobuf:"bytes,7,opt,name=lowStr,proto3" json:"lowStr,omitempty"`
	CloseStr string `protobuf:"bytes,8,opt,name=closeStr,proto3" json:"closeStr,omitempty"`
	// Deprecated
	Open                 float32  `protobuf:"fixed32,1,opt,name=open,proto3" json:"open,omitempty"`
	High                 float32  `protobuf:"fixed32,2,opt,name=high,proto3" json:"high,omitempty"`
	Low                  float32  `protobuf:"fixed32,3,opt,name=low,proto3" json:"low,omitempty"`
	Close                float32  `protobuf:"fixed32,4,opt,name=close,proto3" json:"close,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Interval_OHLC) Reset()         { *m = Interval_OHLC{} }
func (m *Interval_OHLC) String() string { return proto.CompactTextString(m) }
func (*Interval_OHLC) ProtoMessage()    {}
func (*Interval_OHLC) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{8, 0}
}
func (m *Interval_OHLC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interval_OHLC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interval_OHLC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Interval_OHLC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interval_OHLC.Merge(dst, src)
}
func (m *Interval_OHLC) XXX_Size() int {
	return m.Size()
}
func (m *Interval_OHLC) XXX_DiscardUnknown() {
	xxx_messageInfo_Interval_OHLC.DiscardUnknown(m)
}

var xxx_messageInfo_Interval_OHLC proto.InternalMessageInfo

func (m *Interval_OHLC) GetOpenStr() string {
	if m != nil {
		return m.OpenStr
	}
	return ""
}

func (m *Interval_OHLC) GetHighStr() string {
	if m != nil {
		return m.HighStr
	}
	return ""
}

func (m *Interval_OHLC) GetLowStr() string {
	if m != nil {
		return m.LowStr
	}
	return ""
}

func (m *Interval_OHLC) GetCloseStr() string {
	if m != nil {
		return m.CloseStr
	}
	return ""
}

func (m *Interval_OHLC) GetOpen() float32 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *Interval_OHLC) GetHigh() float32 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *Interval_OHLC) GetLow() float32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *Interval_OHLC) GetClose() float32 {
	if m != nil {
		return m.Close
	}
	return 0
}

// IntervalsUpdate represents a set of new Intervals (OHLC candles)
type IntervalsUpdate struct {
	Intervals            []*Interval `protobuf:"bytes,1,rep,name=intervals,proto3" json:"intervals,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IntervalsUpdate) Reset()         { *m = IntervalsUpdate{} }
func (m *IntervalsUpdate) String() string { return proto.CompactTextString(m) }
func (*IntervalsUpdate) ProtoMessage()    {}
func (*IntervalsUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{9}
}
func (m *IntervalsUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntervalsUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntervalsUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IntervalsUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntervalsUpdate.Merge(dst, src)
}
func (m *IntervalsUpdate) XXX_Size() int {
	return m.Size()
}
func (m *IntervalsUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_IntervalsUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_IntervalsUpdate proto.InternalMessageInfo

func (m *IntervalsUpdate) GetIntervals() []*Interval {
	if m != nil {
		return m.Intervals
	}
	return nil
}

// SummaryUpdate is a market summary update
type SummaryUpdate struct {
	LastStr           string `protobuf:"bytes,10,opt,name=lastStr,proto3" json:"lastStr,omitempty"`
	HighStr           string `protobuf:"bytes,11,opt,name=highStr,proto3" json:"highStr,omitempty"`
	LowStr            string `protobuf:"bytes,12,opt,name=lowStr,proto3" json:"lowStr,omitempty"`
	VolumeBaseStr     string `protobuf:"bytes,13,opt,name=volumeBaseStr,proto3" json:"volumeBaseStr,omitempty"`
	VolumeQuoteStr    string `protobuf:"bytes,14,opt,name=volumeQuoteStr,proto3" json:"volumeQuoteStr,omitempty"`
	ChangeAbsoluteStr string `protobuf:"bytes,15,opt,name=changeAbsoluteStr,proto3" json:"changeAbsoluteStr,omitempty"`
	ChangePercentStr  string `protobuf:"bytes,16,opt,name=changePercentStr,proto3" json:"changePercentStr,omitempty"`
	NumTrades         int32  `protobuf:"varint,8,opt,name=numTrades,proto3" json:"numTrades,omitempty"`
	// Deprecated
	Last                 float32  `protobuf:"fixed32,2,opt,name=last,proto3" json:"last,omitempty"`
	High                 float32  `protobuf:"fixed32,3,opt,name=high,proto3" json:"high,omitempty"`
	Low                  float32  `protobuf:"fixed32,4,opt,name=low,proto3" json:"low,omitempty"`
	VolumeBase           float32  `protobuf:"fixed32,5,opt,name=volumeBase,proto3" json:"volumeBase,omitempty"`
	VolumeQuote          float32  `protobuf:"fixed32,9,opt,name=volumeQuote,proto3" json:"volumeQuote,omitempty"`
	ChangeAbsolute       float32  `protobuf:"fixed32,6,opt,name=changeAbsolute,proto3" json:"changeAbsolute,omitempty"`
	ChangePercent        float32  `protobuf:"fixed32,7,opt,name=changePercent,proto3" json:"changePercent,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SummaryUpdate) Reset()         { *m = SummaryUpdate{} }
func (m *SummaryUpdate) String() string { return proto.CompactTextString(m) }
func (*SummaryUpdate) ProtoMessage()    {}
func (*SummaryUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{10}
}
func (m *SummaryUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SummaryUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SummaryUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SummaryUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SummaryUpdate.Merge(dst, src)
}
func (m *SummaryUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SummaryUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SummaryUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SummaryUpdate proto.InternalMessageInfo

func (m *SummaryUpdate) GetLastStr() string {
	if m != nil {
		return m.LastStr
	}
	return ""
}

func (m *SummaryUpdate) GetHighStr() string {
	if m != nil {
		return m.HighStr
	}
	return ""
}

func (m *SummaryUpdate) GetLowStr() string {
	if m != nil {
		return m.LowStr
	}
	return ""
}

func (m *SummaryUpdate) GetVolumeBaseStr() string {
	if m != nil {
		return m.VolumeBaseStr
	}
	return ""
}

func (m *SummaryUpdate) GetVolumeQuoteStr() string {
	if m != nil {
		return m.VolumeQuoteStr
	}
	return ""
}

func (m *SummaryUpdate) GetChangeAbsoluteStr() string {
	if m != nil {
		return m.ChangeAbsoluteStr
	}
	return ""
}

func (m *SummaryUpdate) GetChangePercentStr() string {
	if m != nil {
		return m.ChangePercentStr
	}
	return ""
}

func (m *SummaryUpdate) GetNumTrades() int32 {
	if m != nil {
		return m.NumTrades
	}
	return 0
}

func (m *SummaryUpdate) GetLast() float32 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *SummaryUpdate) GetHigh() float32 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *SummaryUpdate) GetLow() float32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *SummaryUpdate) GetVolumeBase() float32 {
	if m != nil {
		return m.VolumeBase
	}
	return 0
}

func (m *SummaryUpdate) GetVolumeQuote() float32 {
	if m != nil {
		return m.VolumeQuote
	}
	return 0
}

func (m *SummaryUpdate) GetChangeAbsolute() float32 {
	if m != nil {
		return m.ChangeAbsolute
	}
	return 0
}

func (m *SummaryUpdate) GetChangePercent() float32 {
	if m != nil {
		return m.ChangePercent
	}
	return 0
}

type SparklineUpdate struct {
	Time                 int64    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Price                float32  `protobuf:"fixed32,3,opt,name=price,proto3" json:"price,omitempty"`
	PriceStr             string   `protobuf:"bytes,4,opt,name=priceStr,proto3" json:"priceStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SparklineUpdate) Reset()         { *m = SparklineUpdate{} }
func (m *SparklineUpdate) String() string { return proto.CompactTextString(m) }
func (*SparklineUpdate) ProtoMessage()    {}
func (*SparklineUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_9483d2abd41809cd, []int{11}
}
func (m *SparklineUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparklineUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparklineUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SparklineUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparklineUpdate.Merge(dst, src)
}
func (m *SparklineUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SparklineUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SparklineUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SparklineUpdate proto.InternalMessageInfo

func (m *SparklineUpdate) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SparklineUpdate) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *SparklineUpdate) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func init() {
	proto.RegisterType((*Market)(nil), "ProtobufMarkets.Market")
	proto.RegisterType((*Order)(nil), "ProtobufMarkets.Order")
	proto.RegisterType((*Trade)(nil), "ProtobufMarkets.Trade")
	proto.RegisterType((*MarketUpdateMessage)(nil), "ProtobufMarkets.MarketUpdateMessage")
	proto.RegisterType((*OrderBookUpdate)(nil), "ProtobufMarkets.OrderBookUpdate")
	proto.RegisterType((*OrderBookDeltaUpdate)(nil), "ProtobufMarkets.OrderBookDeltaUpdate")
	proto.RegisterType((*OrderBookDeltaUpdate_OrderDeltas)(nil), "ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas")
	proto.RegisterType((*OrderBookSpreadUpdate)(nil), "ProtobufMarkets.OrderBookSpreadUpdate")
	proto.RegisterType((*TradesUpdate)(nil), "ProtobufMarkets.TradesUpdate")
	proto.RegisterType((*Interval)(nil), "ProtobufMarkets.Interval")
	proto.RegisterType((*Interval_OHLC)(nil), "ProtobufMarkets.Interval.OHLC")
	proto.RegisterType((*IntervalsUpdate)(nil), "ProtobufMarkets.IntervalsUpdate")
	proto.RegisterType((*SummaryUpdate)(nil), "ProtobufMarkets.SummaryUpdate")
	proto.RegisterType((*SparklineUpdate)(nil), "ProtobufMarkets.SparklineUpdate")
}
func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Exchange) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.Exchange)))
		i += copy(dAtA[i:], m.Exchange)
	}
	if len(m.CurrencyPair) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.CurrencyPair)))
		i += copy(dAtA[i:], m.CurrencyPair)
	}
	if m.ExchangeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.ExchangeId))
	}
	if m.CurrencyPairId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.CurrencyPairId))
	}
	if m.MarketId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.MarketId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Price))))
		i += 4
	}
	if m.Amount != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i += 4
	}
	if len(m.PriceStr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PriceStr)))
		i += copy(dAtA[i:], m.PriceStr)
	}
	if len(m.AmountStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AmountStr)))
		i += copy(dAtA[i:], m.AmountStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Id))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Timestamp))
	}
	if m.Price != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Price))))
		i += 4
	}
	if m.Amount != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i += 4
	}
	if m.TimestampMillis != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.TimestampMillis))
	}
	if m.PriceDouble != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PriceDouble))))
		i += 8
	}
	if m.AmountDouble != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AmountDouble))))
		i += 8
	}
	if len(m.PriceStr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PriceStr)))
		i += copy(dAtA[i:], m.PriceStr)
	}
	if len(m.AmountStr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AmountStr)))
		i += copy(dAtA[i:], m.AmountStr)
	}
	if m.TimestampNano != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.TimestampNano))
	}
	if len(m.ExternalId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.ExternalId)))
		i += copy(dAtA[i:], m.ExternalId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarketUpdateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		nn1, err := m.Update.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.Market != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Market.Size()))
		n2, err := m.Market.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarketUpdateMessage_OrderBookUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookUpdate != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookUpdate.Size()))
		n3, err := m.OrderBookUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *MarketUpdateMessage_OrderBookDeltaUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookDeltaUpdate != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookDeltaUpdate.Size()))
		n4, err := m.OrderBookDeltaUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *MarketUpdateMessage_TradesUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TradesUpdate != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.TradesUpdate.Size()))
		n5, err := m.TradesUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *MarketUpdateMessage_IntervalsUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IntervalsUpdate != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.IntervalsUpdate.Size()))
		n6, err := m.IntervalsUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *MarketUpdateMessage_SummaryUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SummaryUpdate != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SummaryUpdate.Size()))
		n7, err := m.SummaryUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *MarketUpdateMessage_SparklineUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparklineUpdate != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SparklineUpdate.Size()))
		n8, err := m.SparklineUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *MarketUpdateMessage_OrderBookSpreadUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookSpreadUpdate != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookSpreadUpdate.Size()))
		n9, err := m.OrderBookSpreadUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *OrderBookUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bids) > 0 {
		for _, msg := range m.Bids {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Asks) > 0 {
		for _, msg := range m.Asks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AggregationModulus != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AggregationModulus))))
		i += 4
	}
	if len(m.AggregationModulusStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AggregationModulusStr)))
		i += copy(dAtA[i:], m.AggregationModulusStr)
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookDeltaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookDeltaUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bids != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bids.Size()))
		n10, err := m.Bids.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Asks != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Asks.Size()))
		n11, err := m.Asks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.AggregationModulus != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AggregationModulus))))
		i += 4
	}
	if len(m.AggregationModulusStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AggregationModulusStr)))
		i += copy(dAtA[i:], m.AggregationModulusStr)
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, msg := range m.Set {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Delta) > 0 {
		for _, msg := range m.Delta {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Remove) > 0 {
		for _, num := range m.Remove {
			dAtA[i] = 0x1d
			i++
			f12 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f12))
			i += 4
		}
	}
	if len(m.RemoveStr) > 0 {
		for _, s := range m.RemoveStr {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookSpreadUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookSpreadUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Timestamp))
	}
	if m.Bid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bid.Size()))
		n13, err := m.Bid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Ask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Ask.Size()))
		n14, err := m.Ask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TradesUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradesUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for _, msg := range m.Trades {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Interval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Closetime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Closetime))
	}
	if m.Ohlc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Ohlc.Size()))
		n15, err := m.Ohlc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.VolumeBase != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.VolumeBase))))
		i += 4
	}
	if m.Period != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Period))
	}
	if m.VolumeQuote != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.VolumeQuote))))
		i += 4
	}
	if len(m.VolumeBaseStr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeBaseStr)))
		i += copy(dAtA[i:], m.VolumeBaseStr)
	}
	if len(m.VolumeQuoteStr) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeQuoteStr)))
		i += copy(dAtA[i:], m.VolumeQuoteStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Interval_OHLC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interval_OHLC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Open != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Open))))
		i += 4
	}
	if m.High != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.High))))
		i += 4
	}
	if m.Low != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Low))))
		i += 4
	}
	if m.Close != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Close))))
		i += 4
	}
	if len(m.OpenStr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.OpenStr)))
		i += copy(dAtA[i:], m.OpenStr)
	}
	if len(m.HighStr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.HighStr)))
		i += copy(dAtA[i:], m.HighStr)
	}
	if len(m.LowStr) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.LowStr)))
		i += copy(dAtA[i:], m.LowStr)
	}
	if len(m.CloseStr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.CloseStr)))
		i += copy(dAtA[i:], m.CloseStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IntervalsUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalsUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Intervals) > 0 {
		for _, msg := range m.Intervals {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SummaryUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummaryUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Last != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Last))))
		i += 4
	}
	if m.High != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.High))))
		i += 4
	}
	if m.Low != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Low))))
		i += 4
	}
	if m.VolumeBase != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.VolumeBase))))
		i += 4
	}
	if m.ChangeAbsolute != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChangeAbsolute))))
		i += 4
	}
	if m.ChangePercent != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChangePercent))))
		i += 4
	}
	if m.NumTrades != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.NumTrades))
	}
	if m.VolumeQuote != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.VolumeQuote))))
		i += 4
	}
	if len(m.LastStr) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.LastStr)))
		i += copy(dAtA[i:], m.LastStr)
	}
	if len(m.HighStr) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.HighStr)))
		i += copy(dAtA[i:], m.HighStr)
	}
	if len(m.LowStr) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.LowStr)))
		i += copy(dAtA[i:], m.LowStr)
	}
	if len(m.VolumeBaseStr) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeBaseStr)))
		i += copy(dAtA[i:], m.VolumeBaseStr)
	}
	if len(m.VolumeQuoteStr) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeQuoteStr)))
		i += copy(dAtA[i:], m.VolumeQuoteStr)
	}
	if len(m.ChangeAbsoluteStr) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.ChangeAbsoluteStr)))
		i += copy(dAtA[i:], m.ChangeAbsoluteStr)
	}
	if len(m.ChangePercentStr) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.ChangePercentStr)))
		i += copy(dAtA[i:], m.ChangePercentStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SparklineUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparklineUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Time))
	}
	if m.Price != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Price))))
		i += 4
	}
	if len(m.PriceStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PriceStr)))
		i += copy(dAtA[i:], m.PriceStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMarket(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exchange)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.CurrencyPair)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.ExchangeId != 0 {
		n += 1 + sovMarket(uint64(m.ExchangeId))
	}
	if m.CurrencyPairId != 0 {
		n += 1 + sovMarket(uint64(m.CurrencyPairId))
	}
	if m.MarketId != 0 {
		n += 1 + sovMarket(uint64(m.MarketId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Price != 0 {
		n += 5
	}
	if m.Amount != 0 {
		n += 5
	}
	l = len(m.PriceStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.AmountStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMarket(uint64(m.Id))
	}
	if m.Timestamp != 0 {
		n += 1 + sovMarket(uint64(m.Timestamp))
	}
	if m.Price != 0 {
		n += 5
	}
	if m.Amount != 0 {
		n += 5
	}
	if m.TimestampMillis != 0 {
		n += 1 + sovMarket(uint64(m.TimestampMillis))
	}
	if m.PriceDouble != 0 {
		n += 9
	}
	if m.AmountDouble != 0 {
		n += 9
	}
	l = len(m.PriceStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.AmountStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.TimestampNano != 0 {
		n += 1 + sovMarket(uint64(m.TimestampNano))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarketUpdateMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		n += m.Update.Size()
	}
	if m.Market != nil {
		l = m.Market.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarketUpdateMessage_OrderBookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookUpdate != nil {
		l = m.OrderBookUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_OrderBookDeltaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookDeltaUpdate != nil {
		l = m.OrderBookDeltaUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_TradesUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradesUpdate != nil {
		l = m.TradesUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_IntervalsUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntervalsUpdate != nil {
		l = m.IntervalsUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_SummaryUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SummaryUpdate != nil {
		l = m.SummaryUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_SparklineUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SparklineUpdate != nil {
		l = m.SparklineUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_OrderBookSpreadUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookSpreadUpdate != nil {
		l = m.OrderBookSpreadUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *OrderBookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bids) > 0 {
		for _, e := range m.Bids {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.Asks) > 0 {
		for _, e := range m.Asks {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.AggregationModulus != 0 {
		n += 5
	}
	l = len(m.AggregationModulusStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovMarket(uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookDeltaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bids != nil {
		l = m.Bids.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Asks != nil {
		l = m.Asks.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.AggregationModulus != 0 {
		n += 5
	}
	l = len(m.AggregationModulusStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovMarket(uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.Delta) > 0 {
		for _, e := range m.Delta {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.Remove) > 0 {
		n += 5 * len(m.Remove)
	}
	if len(m.RemoveStr) > 0 {
		for _, s := range m.RemoveStr {
			l = len(s)
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookSpreadUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMarket(uint64(m.Timestamp))
	}
	if m.Bid != nil {
		l = m.Bid.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Ask != nil {
		l = m.Ask.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TradesUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Interval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Closetime != 0 {
		n += 1 + sovMarket(uint64(m.Closetime))
	}
	if m.Ohlc != nil {
		l = m.Ohlc.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.VolumeBase != 0 {
		n += 5
	}
	if m.Period != 0 {
		n += 1 + sovMarket(uint64(m.Period))
	}
	if m.VolumeQuote != 0 {
		n += 5
	}
	l = len(m.VolumeBaseStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.VolumeQuoteStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Interval_OHLC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != 0 {
		n += 5
	}
	if m.High != 0 {
		n += 5
	}
	if m.Low != 0 {
		n += 5
	}
	if m.Close != 0 {
		n += 5
	}
	l = len(m.OpenStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.HighStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.LowStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.CloseStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntervalsUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Intervals) > 0 {
		for _, e := range m.Intervals {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SummaryUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Last != 0 {
		n += 5
	}
	if m.High != 0 {
		n += 5
	}
	if m.Low != 0 {
		n += 5
	}
	if m.VolumeBase != 0 {
		n += 5
	}
	if m.ChangeAbsolute != 0 {
		n += 5
	}
	if m.ChangePercent != 0 {
		n += 5
	}
	if m.NumTrades != 0 {
		n += 1 + sovMarket(uint64(m.NumTrades))
	}
	if m.VolumeQuote != 0 {
		n += 5
	}
	l = len(m.LastStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.HighStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.LowStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.VolumeBaseStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.VolumeQuoteStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.ChangeAbsoluteStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.ChangePercentStr)
	if l > 0 {
		n += 2 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SparklineUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovMarket(uint64(m.Time))
	}
	if m.Price != 0 {
		n += 5
	}
	l = len(m.PriceStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMarket(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMarket(x uint64) (n int) {
	return sovMarket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyPair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyPair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			m.ExchangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyPairId", wireType)
			}
			m.CurrencyPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyPairId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Price = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Price = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMillis", wireType)
			}
			m.TimestampMillis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMillis |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PriceDouble = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AmountDouble = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNano", wireType)
			}
			m.TimestampNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampNano |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketUpdateMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketUpdateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketUpdateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookUpdate{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookDeltaUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookDeltaUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookDeltaUpdate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradesUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TradesUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_TradesUpdate{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalsUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntervalsUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_IntervalsUpdate{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SummaryUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SummaryUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_SummaryUpdate{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparklineUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparklineUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_SparklineUpdate{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Market == nil {
				m.Market = &Market{}
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookSpreadUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookSpreadUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookSpreadUpdate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bids = append(m.Bids, &Order{})
			if err := m.Bids[len(m.Bids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asks = append(m.Asks, &Order{})
			if err := m.Asks[len(m.Asks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationModulus", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AggregationModulus = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationModulusStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationModulusStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookDeltaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookDeltaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookDeltaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bids == nil {
				m.Bids = &OrderBookDeltaUpdate_OrderDeltas{}
			}
			if err := m.Bids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asks == nil {
				m.Asks = &OrderBookDeltaUpdate_OrderDeltas{}
			}
			if err := m.Asks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationModulus", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AggregationModulus = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationModulusStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationModulusStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookDeltaUpdate_OrderDeltas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderDeltas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderDeltas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Order{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delta = append(m.Delta, &Order{})
			if err := m.Delta[len(m.Delta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Remove = append(m.Remove, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMarket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMarket
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Remove) == 0 {
					m.Remove = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Remove = append(m.Remove, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoveStr = append(m.RemoveStr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookSpreadUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookSpreadUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookSpreadUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bid == nil {
				m.Bid = &Order{}
			}
			if err := m.Bid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ask == nil {
				m.Ask = &Order{}
			}
			if err := m.Ask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradesUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradesUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradesUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, &Trade{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closetime", wireType)
			}
			m.Closetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Closetime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ohlc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ohlc == nil {
				m.Ohlc = &Interval_OHLC{}
			}
			if err := m.Ohlc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeBase", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.VolumeBase = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeQuote", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.VolumeQuote = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeBaseStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeBaseStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeQuoteStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeQuoteStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interval_OHLC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OHLC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OHLC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Open = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.High = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Low = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Close = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloseStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalsUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalsUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalsUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intervals = append(m.Intervals, &Interval{})
			if err := m.Intervals[len(m.Intervals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummaryUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummaryUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummaryUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Last = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.High = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Low = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeBase", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.VolumeBase = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAbsolute", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChangeAbsolute = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChangePercent = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTrades", wireType)
			}
			m.NumTrades = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTrades |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeQuote", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.VolumeQuote = float32(math.Float32frombits(v))
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeBaseStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeBaseStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeQuoteStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeQuoteStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAbsoluteStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeAbsoluteStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePercentStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangePercentStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparklineUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparklineUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparklineUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Price = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMarket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMarket
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMarket
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMarket(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMarket = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMarket   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("markets/market.proto", fileDescriptor_market_9483d2abd41809cd) }

var fileDescriptor_market_9483d2abd41809cd = []byte{
	// 1156 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcf, 0x6e, 0x23, 0xc5,
	0x13, 0xf6, 0xfc, 0x73, 0xec, 0x72, 0x12, 0xfb, 0xd7, 0xbf, 0x64, 0x19, 0x22, 0xb0, 0xac, 0x11,
	0xac, 0xac, 0xd5, 0xca, 0x2b, 0x02, 0x12, 0x37, 0x24, 0xb2, 0xbb, 0xc8, 0x89, 0x36, 0x9b, 0xd0,
	0x59, 0x4e, 0x08, 0xa4, 0xb6, 0xa7, 0x71, 0x46, 0x1e, 0xcf, 0x98, 0xe9, 0x99, 0x2c, 0xfb, 0x08,
	0xf0, 0x04, 0xdc, 0x78, 0x01, 0x9e, 0x81, 0x13, 0x48, 0x1c, 0x91, 0x78, 0x01, 0x14, 0x0e, 0x9c,
	0x79, 0x03, 0x54, 0xdd, 0xed, 0xf1, 0xcc, 0xd8, 0xb3, 0xbb, 0xe2, 0xc2, 0x29, 0x5d, 0x5f, 0x7f,
	0xfd, 0x4d, 0x75, 0x55, 0xb9, 0xba, 0x02, 0x07, 0x0b, 0x96, 0xcc, 0x79, 0x2a, 0x1e, 0xa8, 0xbf,
	0xa3, 0x65, 0x12, 0xa7, 0x31, 0xe9, 0x5e, 0xe2, 0x9f, 0x49, 0xf6, 0xd5, 0xb9, 0xda, 0xf5, 0x7e,
	0x34, 0xa0, 0xa9, 0xd6, 0xe4, 0x08, 0x5a, 0xfc, 0x9b, 0xe9, 0x35, 0x8b, 0x66, 0xdc, 0x35, 0x06,
	0xc6, 0xb0, 0x4d, 0x73, 0x9b, 0x78, 0xb0, 0x3b, 0xcd, 0x92, 0x84, 0x47, 0xd3, 0x17, 0x97, 0x2c,
	0x48, 0x5c, 0x53, 0xee, 0x97, 0x30, 0xd2, 0x07, 0x58, 0xf1, 0x4f, 0x7d, 0xd7, 0x1a, 0x18, 0x43,
	0x9b, 0x16, 0x10, 0x72, 0x17, 0xf6, 0x8b, 0xfc, 0x53, 0xdf, 0xb5, 0x25, 0xa7, 0x82, 0xa2, 0x1f,
	0xca, 0xe7, 0x53, 0xdf, 0x75, 0x24, 0x23, 0xb7, 0xbd, 0x18, 0x9c, 0x8b, 0xc4, 0xe7, 0x09, 0x39,
	0x00, 0x67, 0x99, 0x04, 0x53, 0xe5, 0xa9, 0x49, 0x95, 0x41, 0xee, 0x40, 0x93, 0x2d, 0xe2, 0x2c,
	0x4a, 0xa5, 0x83, 0x26, 0xd5, 0x16, 0x4a, 0x4a, 0xc2, 0x55, 0x9a, 0x48, 0xc7, 0xda, 0x34, 0xb7,
	0xc9, 0x5b, 0xd0, 0x56, 0x2c, 0xdc, 0xb4, 0xe5, 0xe6, 0x1a, 0xf0, 0x7e, 0x37, 0xc1, 0x79, 0x96,
	0x30, 0x9f, 0x93, 0x7d, 0x30, 0x03, 0x5f, 0x7e, 0xce, 0xa2, 0x66, 0xe0, 0xe3, 0xb9, 0x34, 0x58,
	0x70, 0x91, 0xb2, 0xc5, 0x52, 0x7e, 0xce, 0xa2, 0x6b, 0x60, 0xed, 0x9f, 0xb5, 0xdd, 0x3f, 0xbb,
	0xe4, 0xdf, 0x10, 0xba, 0xf9, 0xd1, 0xf3, 0x20, 0x0c, 0x03, 0x21, 0x6f, 0x6e, 0xd1, 0x2a, 0x4c,
	0x06, 0xd0, 0x91, 0x52, 0x8f, 0xe2, 0x6c, 0x12, 0x72, 0xb7, 0x39, 0x30, 0x86, 0x06, 0x2d, 0x42,
	0x98, 0x2a, 0xa5, 0xaa, 0x29, 0x3b, 0x92, 0x52, 0xc2, 0x4a, 0xf1, 0x68, 0xbd, 0x2c, 0x1e, 0xed,
	0x4a, 0x3c, 0xc8, 0x3b, 0xb0, 0x97, 0xbb, 0xf4, 0x94, 0x45, 0xb1, 0x0b, 0xd2, 0xcf, 0x32, 0xa8,
	0x4a, 0x21, 0xe5, 0x49, 0xc4, 0xc2, 0x53, 0xdf, 0xed, 0x48, 0x91, 0x02, 0xe2, 0x7d, 0xe7, 0xc0,
	0xff, 0x55, 0xd5, 0x7d, 0xb6, 0xf4, 0x59, 0xca, 0xcf, 0xb9, 0x10, 0x6c, 0xc6, 0xc9, 0x13, 0xe8,
	0xc6, 0x98, 0xde, 0x93, 0x38, 0x9e, 0xab, 0x1d, 0x19, 0xd9, 0xce, 0xf1, 0x60, 0x54, 0x29, 0xdc,
	0xd1, 0x45, 0x99, 0x37, 0x6e, 0xd0, 0xea, 0x51, 0xf2, 0x39, 0x1c, 0xe4, 0xd0, 0x23, 0x1e, 0xa6,
	0x4c, 0x4b, 0x5a, 0x52, 0xf2, 0xdd, 0x7a, 0xc9, 0x02, 0x79, 0xdc, 0xa0, 0x5b, 0x45, 0xc8, 0x43,
	0xd8, 0x4d, 0xb1, 0x2e, 0x84, 0x16, 0xb5, 0xa5, 0xe8, 0xdb, 0x1b, 0xa2, 0xcf, 0x0a, 0xa4, 0x71,
	0x83, 0x96, 0x0e, 0xe1, 0x7d, 0x83, 0x28, 0xe5, 0xc9, 0x0d, 0x0b, 0x57, 0x3a, 0x4e, 0xcd, 0x7d,
	0x4f, 0xcb, 0x3c, 0xbc, 0x6f, 0xe5, 0x28, 0xf9, 0x04, 0xf6, 0x44, 0xb6, 0x58, 0xb0, 0xe4, 0x85,
	0xd6, 0x6a, 0x4a, 0xad, 0xfe, 0x86, 0xd6, 0x55, 0x91, 0x35, 0x6e, 0xd0, 0xf2, 0x31, 0xf4, 0x4a,
	0x2c, 0x59, 0x32, 0x0f, 0x83, 0x88, 0x6b, 0xa5, 0x9d, 0x1a, 0xaf, 0xae, 0xca, 0x3c, 0xf4, 0xaa,
	0x72, 0x94, 0x3c, 0x80, 0xa6, 0xfa, 0xf9, 0xca, 0x62, 0xea, 0x1c, 0xbf, 0xb1, 0x21, 0xa2, 0xfe,
	0x52, 0x4d, 0x23, 0x5f, 0xc2, 0x61, 0x1e, 0xf1, 0xab, 0x65, 0xc2, 0x99, 0xaf, 0x9d, 0xe8, 0xc8,
	0xf3, 0x77, 0xeb, 0xf3, 0x56, 0x64, 0x8f, 0x1b, 0x74, 0xbb, 0xcc, 0x49, 0x0b, 0x9a, 0x6a, 0x75,
	0x66, 0xb7, 0x5a, 0xbd, 0xb6, 0xf7, 0x97, 0x01, 0xdd, 0x4a, 0x35, 0x91, 0x7b, 0x60, 0x4f, 0x02,
	0x5f, 0xb8, 0xc6, 0xc0, 0x1a, 0x76, 0x8e, 0xef, 0x6c, 0xff, 0x24, 0x95, 0x1c, 0xe4, 0x32, 0x31,
	0x17, 0xae, 0xf9, 0x72, 0x2e, 0x72, 0xc8, 0x08, 0x08, 0x9b, 0xcd, 0x12, 0x3e, 0x63, 0x69, 0x10,
	0x47, 0xe7, 0xb1, 0x9f, 0x85, 0x99, 0xd0, 0x3d, 0x62, 0xcb, 0x0e, 0xf9, 0x00, 0x0e, 0x37, 0xd1,
	0x75, 0xa3, 0xda, 0xbe, 0x89, 0x6d, 0x46, 0xf0, 0xaf, 0x9f, 0x66, 0x0b, 0x59, 0x4d, 0x0e, 0xd5,
	0x96, 0xf7, 0xb3, 0x05, 0x07, 0xdb, 0x8a, 0x9c, 0x3c, 0xce, 0xaf, 0x8b, 0x11, 0x7e, 0xef, 0xb5,
	0x7e, 0x19, 0x0a, 0x94, 0x80, 0xd0, 0x91, 0x78, 0x9c, 0x47, 0xe2, 0xdf, 0xca, 0xfc, 0xf7, 0x41,
	0x3a, 0xfa, 0xc1, 0x80, 0x4e, 0xc1, 0x27, 0x32, 0x04, 0x4b, 0xf0, 0xf4, 0x15, 0x95, 0x80, 0x14,
	0x72, 0x1f, 0x1c, 0x1f, 0xcf, 0xbc, 0xa2, 0x12, 0x14, 0x89, 0x1c, 0x41, 0x33, 0xe1, 0x8b, 0xf8,
	0x06, 0xfb, 0x91, 0x35, 0x34, 0x4f, 0xcc, 0x5e, 0x83, 0x6a, 0x04, 0x7b, 0xb0, 0x5a, 0xa9, 0x5b,
	0x58, 0xd8, 0x83, 0x73, 0xc0, 0xfb, 0xd6, 0x80, 0xc3, 0xad, 0x35, 0x5f, 0x7e, 0x93, 0x8c, 0xea,
	0x9b, 0x34, 0x04, 0x6b, 0x12, 0xf8, 0x3a, 0x3b, 0xb5, 0x37, 0x99, 0x04, 0x3e, 0x32, 0x99, 0x98,
	0xeb, 0x46, 0x59, 0xcb, 0x64, 0x62, 0xee, 0x7d, 0x04, 0xbb, 0xc5, 0x0e, 0x47, 0x46, 0xd0, 0x54,
	0x1d, 0xae, 0x36, 0x60, 0x92, 0x4e, 0x35, 0xcb, 0xfb, 0xc5, 0x82, 0xd6, 0xaa, 0xb5, 0xa1, 0xfb,
	0xd3, 0x30, 0x16, 0x1c, 0x5d, 0x5e, 0xb9, 0x9f, 0x03, 0xe4, 0x18, 0xec, 0xf8, 0x3a, 0x9c, 0x6a,
	0xff, 0xfb, 0xb5, 0x1d, 0x72, 0x74, 0x31, 0x7e, 0xf2, 0x90, 0x4a, 0x2e, 0x3e, 0x44, 0x37, 0x71,
	0x98, 0x2d, 0xf8, 0x09, 0x13, 0xab, 0xb7, 0xb8, 0x80, 0x60, 0x11, 0x2c, 0x79, 0x12, 0xc4, 0x6a,
	0x16, 0x71, 0xa8, 0xb6, 0xf0, 0x99, 0x55, 0xac, 0x4f, 0xb3, 0x58, 0x37, 0x65, 0x93, 0x16, 0x21,
	0x7c, 0x08, 0xd7, 0x3a, 0x98, 0xa6, 0xa6, 0x2c, 0xb6, 0x32, 0x88, 0x33, 0x4f, 0xe1, 0x10, 0xd2,
	0x76, 0x24, 0xad, 0x82, 0x1e, 0xfd, 0x64, 0x80, 0x8d, 0x6e, 0x13, 0x02, 0x76, 0xbc, 0xe4, 0x91,
	0x1e, 0x6b, 0xe4, 0x1a, 0xb1, 0xeb, 0x60, 0x76, 0xad, 0x67, 0x1a, 0xb9, 0x26, 0x3d, 0xb0, 0xc2,
	0xf8, 0xb9, 0xbe, 0x11, 0x2e, 0x71, 0xe2, 0x90, 0xb1, 0xd2, 0xa3, 0x85, 0x32, 0x88, 0x0b, 0x3b,
	0xa8, 0x81, 0x5f, 0x76, 0xe4, 0x97, 0x57, 0x26, 0xee, 0xa0, 0xd2, 0xda, 0xf5, 0x95, 0x89, 0x41,
	0x09, 0xe3, 0xe7, 0x6b, 0x67, 0xb5, 0x85, 0x53, 0x83, 0x14, 0x2d, 0x4c, 0x0d, 0x2b, 0xdb, 0x3b,
	0x83, 0x6e, 0xe5, 0x85, 0x22, 0x1f, 0x42, 0x3b, 0x7f, 0xa1, 0x74, 0x35, 0xbc, 0x59, 0x9b, 0x34,
	0xba, 0xe6, 0x7a, 0x7f, 0x5b, 0xb0, 0x57, 0x7a, 0xa2, 0x30, 0x02, 0x21, 0x13, 0xab, 0xa9, 0x4e,
	0xae, 0xf3, 0xa8, 0x58, 0x9b, 0x51, 0xb1, 0xd7, 0x51, 0x29, 0x17, 0x80, 0xb3, 0x51, 0x00, 0x38,
	0x94, 0xca, 0x01, 0xf5, 0xe3, 0x89, 0x88, 0xc3, 0x4c, 0x3f, 0x9a, 0x26, 0xad, 0xa0, 0x98, 0x6e,
	0x85, 0x5c, 0xf2, 0x64, 0xca, 0xa3, 0x54, 0x86, 0xc6, 0xa4, 0x65, 0x10, 0x0b, 0x38, 0xca, 0x16,
	0xea, 0x07, 0x21, 0x43, 0xe4, 0xd0, 0x35, 0x50, 0x2d, 0xaa, 0xf6, 0x66, 0x51, 0xb9, 0xb0, 0x83,
	0x77, 0xc3, 0x00, 0x83, 0xca, 0x89, 0x36, 0x8b, 0xd9, 0xea, 0xd4, 0x65, 0x6b, 0xb7, 0x94, 0xad,
	0x8d, 0x02, 0xdd, 0x7b, 0xbd, 0x02, 0xdd, 0xdf, 0x56, 0xa0, 0xe4, 0x3e, 0xfc, 0xaf, 0x1c, 0x11,
	0xa4, 0x76, 0x25, 0x75, 0x73, 0x83, 0xdc, 0x83, 0x5e, 0x29, 0x30, 0x48, 0xee, 0x49, 0xf2, 0x06,
	0x7e, 0x66, 0xb7, 0x8c, 0x9e, 0xe9, 0x7d, 0x01, 0xdd, 0xca, 0x2c, 0x81, 0x09, 0x96, 0x8d, 0x40,
	0xcd, 0xd6, 0x72, 0x5d, 0x33, 0x56, 0x17, 0xc7, 0x59, 0xbb, 0x3c, 0xce, 0x2a, 0xf9, 0x93, 0xde,
	0xaf, 0xb7, 0x7d, 0xe3, 0xb7, 0xdb, 0xbe, 0xf1, 0xc7, 0x6d, 0xdf, 0xf8, 0xfe, 0xcf, 0x7e, 0x63,
	0xd2, 0x94, 0xff, 0x10, 0xbd, 0xff, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbd, 0xcd, 0xba, 0x18,
	0x28, 0x0d, 0x00, 0x00,
}
